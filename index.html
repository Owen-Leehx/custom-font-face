<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>custom your font-face</title>
    <style>
      body {
        background-color: antiquewhite;
      }
      .main {
        /* background-color: antiquewhite; */
      }
      #signature {
        /* border: 5px solid #000; */
      }
      #canvas {
        background-color: antiquewhite;
        /* background-image: linear-gradient(90deg, #ffffff 10%, rgba(0, 0, 0, 0) 10%), linear-gradient(#ffffff 10%, rgba(0, 0, 0, 0) 10%); */
        /* background-size: 20px 20px; */
        background-image: linear-gradient(90deg, #ffffff 2%, rgba(0, 0, 0, 0) 2%), linear-gradient(#ffffff 2%, rgba(0, 0, 0, 0) 2%);
        background-size: 30px 30px;
      }
      #cover {
        position: fixed;
        left: 0;
        right: 0;
        top: 0;
        bottom: 0;
        background-color: rgba(0, 0, 0, 0.1);
        display: none;
        z-index: 999;
      }
      #msgContent {
        width: 500px;
      }
      .flex {
        display: flex;
        padding: 8px;
      }
    </style>
  </head>
  <body>
    <div class="main">
      <div class="flex">
        <div class="flex">
          <h1 id="word">a</h1>
          <button id="next" onclick="next()">record</button>
        </div>

        <div class="flex">
          <input type="file" id="file-input" accept=".json" />
          <div>
            <button onclick="download()">download</button>
            <a href="./font-face.json" download="default-font-face">default font face</a>
          </div>
        </div>
      </div>

      <div class="flex"><textarea id="msgContent"></textarea><button onclick="recoverDraw()">write</button></div>

      <div id="signature">
        <canvas id="canvas"></canvas>
      </div>

      <!-- <div id="cover"></div> -->

      <div id="test">test a</div>
      <div>
        <form>
          <select id="selectTest">
            <option>1</option>
            <option>2</option>
            <option>3</option>
          </select>
          <input id="inputTest" />
          <textarea id="textareaTest"></textarea>
        </form>
        <!--  -->
      </div>
    </div>

    <script>
      let dictMap = JSON.parse(localStorage.getItem('dictMap') || '[]') || []
      const socket = new WebSocket(localStorage.getItem('useMyWebSocket') || 'wss://127.0.0.1:8001')
      const txt = document.getElementById('test')
      const word = document.getElementById('word')
      const params = new URLSearchParams(location.search)
      const userId = params.get('userId')
      let history = []

      let record = []
      let isDrawing = false
      let isRecording = false

      const msgContent = document.getElementById('msgContent')

      function onchange(e) {
        const val = e.target.value?.toLowerCase()
        writeMsg(val)
      }

      function writeMsg(msg) {
        const list = msg.split('').reduce((result, item) => {
          const val = dictMap.find((dic) => dic.code === item)
          result.push(val)
          return result
        }, [])

        history = list
          .map((item, index) =>
            item?.value.map((child) => {
              const { type, point } = child
              return { type, point: [point[0] + (index % (16 * dpr)) * 100, point[1] + Math.floor(index / (16 * dpr)) * 180] }
            })
          )
          .filter((item) => item)
          .flat(1)

        localStorage.setItem('localRecord', JSON.stringify(history))
      }

      msgContent.addEventListener('change', onchange)

      function throttle(func, delay) {
        let lastExecutionTime = 0 // 上次执行时间

        // 返回一个包装函数
        return function (...args) {
          const now = new Date().getTime() // 获取当前时间
          const timeSinceLastExecution = now - lastExecutionTime // 计算距离上次执行的时间差

          // 如果达到了执行间隔，则执行函数
          if (timeSinceLastExecution >= delay) {
            func.apply(this, args) // 执行原始函数，并传递参数
            lastExecutionTime = now // 更新上次执行时间为当前时间
          }
        }
      }

      function downloadJSON(jsonData, fileName) {
        // 将JSON对象转换为字符串
        const jsonStr = JSON.stringify(jsonData, null, 2) // 第三个参数是缩进量，使输出更易读

        // 创建一个Blob对象，包含JSON字符串
        const blob = new Blob([jsonStr], { type: 'application/json;charset=utf-8' })

        // 创建一个临时的URL指向这个Blob对象
        const url = URL.createObjectURL(blob)

        // 创建隐藏的可下载链接
        const link = document.createElement('a')
        link.href = url
        link.download = fileName || 'data.json' // 设置文件名，默认为"data.json"

        // 触发点击
        document.body.appendChild(link)
        link.click()

        // 然后移除这个链接
        document.body.removeChild(link)

        // 最后释放这个URL对象
        URL.revokeObjectURL(url)
      }

      function download() {
        downloadJSON(dictMap, 'dict')
      }
      function debounce(func, wait) {
        let timeout // 用来存储定时器的标识
        // 返回一个包装函数
        return function (...args) {
          // 如果timeout存在，说明前一次的延迟执行还在排队中，所以 clearTimeout 清除它
          if (timeout) {
            clearTimeout(timeout)
          }

          // 重新设置一个定时器，延迟wait毫秒后执行func函数
          timeout = setTimeout(() => {
            func.apply(this, args) // 执行func函数，并传入原始的参数
          }, wait)
        }
      }
      socket.onopen = function () {
        const content = { type: 'form', id: 'inputTest', value: '向服务端发送数据222' }
        socket.send(JSON.stringify({ from: 'userId' + userId, content }))
      }
      socket.onmessage = function (e) {
        //3
        txt.innerText = e.data
        const { content } = JSON.parse(e.data)
        const { type, id, value } = content
        switch (type) {
          case 'form':
            const formField = document.getElementById(id)
            formField.value = value
            // document.getElementById('imgTest').src=value
            break
          case 'canvas':
            goDraw(value)
            break

          default:
            break
        }
      }

      document.getElementById('file-input').addEventListener('change', function (e) {
        var file = e.target.files[0] // 获取选中的文件
        if (!file) {
          alert('请选择一个文件')
          return
        }

        if (file.type !== 'application/json') {
          alert('请确保选择的是JSON文件')
          return
        }

        var reader = new FileReader()

        // 当读取操作完成时的回调
        reader.onload = function (e) {
          try {
            dictString = e.target.result
            dictMap = JSON.parse(dictString) // 解析读取到的文本为JSON对象
            console.log(dictMap) // 打印JSON数据到控制台
            localStorage.setItem('dictMap', dictString)
            // 在这里处理你的JSON数据，比如渲染到页面上
          } catch (error) {
            console.error('解析JSON数据出错:', error)
          }
        }

        // 开始读取文件内容为文本
        reader.readAsText(file)
      })

      addEventListener('change', (event) => {
        const { id, value } = event.target
        const content = { type: 'form', id, value } // schema-> 数据格式
        socket.send(JSON.stringify({ from: 'userId' + userId, content })) //1
      })

      var canvasEl = document.getElementById('canvas')
      var dpr = window.devicePixelRatio || 1
      canvasEl.width = window.innerWidth * dpr
      canvasEl.height = window.innerHeight * dpr
      canvasEl.style.width = `${window.innerWidth}px`
      canvasEl.style.height = `${window.innerHeight}px`
      var ctx = canvasEl.getContext('2d')
      var rootEl = document.getElementById('signature')
      var rect = canvasEl.getBoundingClientRect()

      ctx.strokeStyle = '#000'
      ctx.lineWidth = 2
      ctx.lineCap = 'round'
      ctx.lineJoin = 'round'
      ctx.shadowBlur = 1
      ctx.shadowColor = '#000'
      ctx.imageSmoothingEnabled = true

      async function copyTextToClipboard(text) {
        try {
          // 等待navigator.clipboard API可用
          await navigator.clipboard.writeText(text)
          console.log('内容已成功复制到剪贴板')
        } catch (err) {
          console.error('无法复制到剪贴板:', err)
        }
      }

      const next = (() => {
        const nextButton = document.getElementById('next')
        const size = 27

        const dict = Array(size)
          .fill(1)
          .map((_, i) => {
            return { code: String.fromCharCode(97 + i), value: [] }
          })

        let i = 0

        function show() {
          const code = dict[i + 1].code
          word.innerText = code
        }

        function save() {
          dict[i].value = JSON.parse(JSON.stringify(record))
          console.log('🚀 ~ save ~ dict[i]:', dict[i])
        }

        function clear() {
          ctx.clearRect(0, 0, canvasEl.width, canvasEl.height)
          record = []
        }

        return () => {
          if (i >= size - 1) {
            word.innerText = JSON.stringify(dict)
            copyTextToClipboard(JSON.stringify(dict))
            downloadJSON(dict, 'dictMap')
            isRecording = false
            nextButton.innerText = 'record'
            return
          }
          if (!isRecording) {
            isRecording = true
            nextButton.innerText = 'next'

            return
          }

          show()
          save()
          clear()
          i++
        }
      })()

      function getPoint(event) {
        var x = event.clientX - rect.left
        var y = event.clientY - rect.top
        return [x * dpr, y * dpr]
      }

      // 开始签名
      function startEvent(event) {
        var point = getPoint(event)
        beginPath(point)
        record.push({ type: 'start', point })
        canvasEl.addEventListener('mousemove', drawSign, false)
        canvasEl.addEventListener('mouseleave', removeEvent, false)
      }
      // 轨迹移动
      function removeEvent(event) {
        canvasEl.removeEventListener('mousemove', drawSign, false)
        canvasEl.removeEventListener('mouseleave', removeEvent, false)
      }
      const sendData = () => {
        const content = { type: 'canvas', id: 'signature', value: record }
        socket.send(JSON.stringify({ from: 'userId' + userId, content }))
        history = [...history, ...record]
        localStorage.setItem('localRecord', JSON.stringify(history))
        record = []
      }

      const debounceSend = debounce(sendData, 1000)

      const recoverDraw = () => {
        ctx.clearRect(0, 0, canvasEl.width, canvasEl.height)
        const localRecord = localStorage.getItem('localRecord')
        try {
          record = JSON.parse(localRecord)
          goDraw(record)
          debounceSend()
        } catch (error) {}
      }

      function drawSign(event) {
        if (isDrawing) return
        var point = getPoint(event)
        record.push({ type: 'draw', point })
        !isRecording && debounceSend()
        handleDrawSign(point)
      }

      function goDraw(value) {
        isDrawing = true
        const len = value.length
        let i = 0

        function step() {
          const item = value[i]
          if (!item) {
            isDrawing = false
            console.log('🚀 ~ step ~ done:')
            return
          }

          const { type, point } = item
          if (type === 'start') {
            beginPath(point)
          } else {
            handleDrawSign(point)
          }
          if (i < len) {
            i++
            requestAnimationFrame(step)
            // step()
          }
        }

        step()
      }

      function beginPath(point) {
        ctx.beginPath.apply(ctx, getPoint(point))
      }

      function handleDrawSign(point) {
        ctx.strokeStyle = `rgba(${Math.floor(Math.random() * 255)},${Math.floor(Math.random() * 255)},${Math.floor(Math.random() * 255)},1)`
        ctx.lineTo.apply(ctx, point)
        ctx.stroke()
      }
      canvasEl.addEventListener('mouseup', removeEvent, false)
      canvasEl.addEventListener('mousedown', startEvent, false)
    </script>
  </body>
</html>
