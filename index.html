<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>custom your font-face</title>
    <style>
      body {
        background-color: antiquewhite;
      }
      .main {
        /* background-color: antiquewhite; */
      }
      #signature {
        /* border: 5px solid #000; */
      }
      #canvas {
        background-color: antiquewhite;
        /* background-image: linear-gradient(90deg, #ffffff 10%, rgba(0, 0, 0, 0) 10%), linear-gradient(#ffffff 10%, rgba(0, 0, 0, 0) 10%); */
        /* background-size: 20px 20px; */
        background-image: linear-gradient(90deg, #ffffff 2%, rgba(0, 0, 0, 0) 2%), linear-gradient(#ffffff 2%, rgba(0, 0, 0, 0) 2%);
        background-size: 30px 30px;
      }
      #cover {
        position: fixed;
        left: 0;
        right: 0;
        top: 0;
        bottom: 0;
        background-color: rgba(0, 0, 0, 0.1);
        display: none;
        z-index: 999;
      }
      #msgContent {
        width: 500px;
      }
      .flex {
        display: flex;
        padding: 8px;
      }
    </style>
  </head>
  <body>
    <div class="main">
      <div class="flex">
        <div class="flex">
          <h1 id="word">a</h1>
          <button id="next" onclick="next()">record</button>
        </div>

        <div class="flex">
          <input type="file" id="file-input" accept=".json" />
          <div>
            <button onclick="download()">download</button>
            <a href="./font-face.json" download="default-font-face">default font face</a>
          </div>
        </div>
      </div>

      <div class="flex"><textarea id="msgContent"></textarea><button onclick="recoverDraw()">write</button></div>

      <div id="signature">
        <canvas id="canvas"></canvas>
      </div>

      <!-- <div id="cover"></div> -->

      <div id="test">test a</div>
      <div>
        <form>
          <select id="selectTest">
            <option>1</option>
            <option>2</option>
            <option>3</option>
          </select>
          <input id="inputTest" />
          <textarea id="textareaTest"></textarea>
        </form>
        <!--  -->
      </div>
    </div>

    <script>
      let dictMap = JSON.parse(localStorage.getItem('dictMap') || '[]') || []
      const socket = new WebSocket(localStorage.getItem('useMyWebSocket') || 'wss://127.0.0.1:8001')
      const txt = document.getElementById('test')
      const word = document.getElementById('word')
      const params = new URLSearchParams(location.search)
      const userId = params.get('userId')
      let history = []

      let record = []
      let isDrawing = false
      let isRecording = false

      const msgContent = document.getElementById('msgContent')

      function onchange(e) {
        const val = e.target.value?.toLowerCase()
        writeMsg(val)
      }

      function writeMsg(msg) {
        const list = msg.split('').reduce((result, item) => {
          const val = dictMap.find((dic) => dic.code === item)
          result.push(val)
          return result
        }, [])

        history = list
          .map((item, index) =>
            item?.value.map((child) => {
              const { type, point } = child
              return { type, point: [point[0] + (index % (16 * dpr)) * 100, point[1] + Math.floor(index / (16 * dpr)) * 180] }
            })
          )
          .filter((item) => item)
          .flat(1)

        localStorage.setItem('localRecord', JSON.stringify(history))
      }

      msgContent.addEventListener('change', onchange)

      function throttle(func, delay) {
        let lastExecutionTime = 0 // ä¸Šæ¬¡æ‰§è¡Œæ—¶é—´

        // è¿”å›žä¸€ä¸ªåŒ…è£…å‡½æ•°
        return function (...args) {
          const now = new Date().getTime() // èŽ·å–å½“å‰æ—¶é—´
          const timeSinceLastExecution = now - lastExecutionTime // è®¡ç®—è·ç¦»ä¸Šæ¬¡æ‰§è¡Œçš„æ—¶é—´å·®

          // å¦‚æžœè¾¾åˆ°äº†æ‰§è¡Œé—´éš”ï¼Œåˆ™æ‰§è¡Œå‡½æ•°
          if (timeSinceLastExecution >= delay) {
            func.apply(this, args) // æ‰§è¡ŒåŽŸå§‹å‡½æ•°ï¼Œå¹¶ä¼ é€’å‚æ•°
            lastExecutionTime = now // æ›´æ–°ä¸Šæ¬¡æ‰§è¡Œæ—¶é—´ä¸ºå½“å‰æ—¶é—´
          }
        }
      }

      function downloadJSON(jsonData, fileName) {
        // å°†JSONå¯¹è±¡è½¬æ¢ä¸ºå­—ç¬¦ä¸²
        const jsonStr = JSON.stringify(jsonData, null, 2) // ç¬¬ä¸‰ä¸ªå‚æ•°æ˜¯ç¼©è¿›é‡ï¼Œä½¿è¾“å‡ºæ›´æ˜“è¯»

        // åˆ›å»ºä¸€ä¸ªBlobå¯¹è±¡ï¼ŒåŒ…å«JSONå­—ç¬¦ä¸²
        const blob = new Blob([jsonStr], { type: 'application/json;charset=utf-8' })

        // åˆ›å»ºä¸€ä¸ªä¸´æ—¶çš„URLæŒ‡å‘è¿™ä¸ªBlobå¯¹è±¡
        const url = URL.createObjectURL(blob)

        // åˆ›å»ºéšè—çš„å¯ä¸‹è½½é“¾æŽ¥
        const link = document.createElement('a')
        link.href = url
        link.download = fileName || 'data.json' // è®¾ç½®æ–‡ä»¶åï¼Œé»˜è®¤ä¸º"data.json"

        // è§¦å‘ç‚¹å‡»
        document.body.appendChild(link)
        link.click()

        // ç„¶åŽç§»é™¤è¿™ä¸ªé“¾æŽ¥
        document.body.removeChild(link)

        // æœ€åŽé‡Šæ”¾è¿™ä¸ªURLå¯¹è±¡
        URL.revokeObjectURL(url)
      }

      function download() {
        downloadJSON(dictMap, 'dict')
      }
      function debounce(func, wait) {
        let timeout // ç”¨æ¥å­˜å‚¨å®šæ—¶å™¨çš„æ ‡è¯†
        // è¿”å›žä¸€ä¸ªåŒ…è£…å‡½æ•°
        return function (...args) {
          // å¦‚æžœtimeoutå­˜åœ¨ï¼Œè¯´æ˜Žå‰ä¸€æ¬¡çš„å»¶è¿Ÿæ‰§è¡Œè¿˜åœ¨æŽ’é˜Ÿä¸­ï¼Œæ‰€ä»¥ clearTimeout æ¸…é™¤å®ƒ
          if (timeout) {
            clearTimeout(timeout)
          }

          // é‡æ–°è®¾ç½®ä¸€ä¸ªå®šæ—¶å™¨ï¼Œå»¶è¿Ÿwaitæ¯«ç§’åŽæ‰§è¡Œfuncå‡½æ•°
          timeout = setTimeout(() => {
            func.apply(this, args) // æ‰§è¡Œfuncå‡½æ•°ï¼Œå¹¶ä¼ å…¥åŽŸå§‹çš„å‚æ•°
          }, wait)
        }
      }
      socket.onopen = function () {
        const content = { type: 'form', id: 'inputTest', value: 'å‘æœåŠ¡ç«¯å‘é€æ•°æ®222' }
        socket.send(JSON.stringify({ from: 'userId' + userId, content }))
      }
      socket.onmessage = function (e) {
        //3
        txt.innerText = e.data
        const { content } = JSON.parse(e.data)
        const { type, id, value } = content
        switch (type) {
          case 'form':
            const formField = document.getElementById(id)
            formField.value = value
            // document.getElementById('imgTest').src=value
            break
          case 'canvas':
            goDraw(value)
            break

          default:
            break
        }
      }

      document.getElementById('file-input').addEventListener('change', function (e) {
        var file = e.target.files[0] // èŽ·å–é€‰ä¸­çš„æ–‡ä»¶
        if (!file) {
          alert('è¯·é€‰æ‹©ä¸€ä¸ªæ–‡ä»¶')
          return
        }

        if (file.type !== 'application/json') {
          alert('è¯·ç¡®ä¿é€‰æ‹©çš„æ˜¯JSONæ–‡ä»¶')
          return
        }

        var reader = new FileReader()

        // å½“è¯»å–æ“ä½œå®Œæˆæ—¶çš„å›žè°ƒ
        reader.onload = function (e) {
          try {
            dictString = e.target.result
            dictMap = JSON.parse(dictString) // è§£æžè¯»å–åˆ°çš„æ–‡æœ¬ä¸ºJSONå¯¹è±¡
            console.log(dictMap) // æ‰“å°JSONæ•°æ®åˆ°æŽ§åˆ¶å°
            localStorage.setItem('dictMap', dictString)
            // åœ¨è¿™é‡Œå¤„ç†ä½ çš„JSONæ•°æ®ï¼Œæ¯”å¦‚æ¸²æŸ“åˆ°é¡µé¢ä¸Š
          } catch (error) {
            console.error('è§£æžJSONæ•°æ®å‡ºé”™:', error)
          }
        }

        // å¼€å§‹è¯»å–æ–‡ä»¶å†…å®¹ä¸ºæ–‡æœ¬
        reader.readAsText(file)
      })

      addEventListener('change', (event) => {
        const { id, value } = event.target
        const content = { type: 'form', id, value } // schema-> æ•°æ®æ ¼å¼
        socket.send(JSON.stringify({ from: 'userId' + userId, content })) //1
      })

      var canvasEl = document.getElementById('canvas')
      var dpr = window.devicePixelRatio || 1
      canvasEl.width = window.innerWidth * dpr
      canvasEl.height = window.innerHeight * dpr
      canvasEl.style.width = `${window.innerWidth}px`
      canvasEl.style.height = `${window.innerHeight}px`
      var ctx = canvasEl.getContext('2d')
      var rootEl = document.getElementById('signature')
      var rect = canvasEl.getBoundingClientRect()

      ctx.strokeStyle = '#000'
      ctx.lineWidth = 2
      ctx.lineCap = 'round'
      ctx.lineJoin = 'round'
      ctx.shadowBlur = 1
      ctx.shadowColor = '#000'
      ctx.imageSmoothingEnabled = true

      async function copyTextToClipboard(text) {
        try {
          // ç­‰å¾…navigator.clipboard APIå¯ç”¨
          await navigator.clipboard.writeText(text)
          console.log('å†…å®¹å·²æˆåŠŸå¤åˆ¶åˆ°å‰ªè´´æ¿')
        } catch (err) {
          console.error('æ— æ³•å¤åˆ¶åˆ°å‰ªè´´æ¿:', err)
        }
      }

      const next = (() => {
        const nextButton = document.getElementById('next')
        const size = 27

        const dict = Array(size)
          .fill(1)
          .map((_, i) => {
            return { code: String.fromCharCode(97 + i), value: [] }
          })

        let i = 0

        function show() {
          const code = dict[i + 1].code
          word.innerText = code
        }

        function save() {
          dict[i].value = JSON.parse(JSON.stringify(record))
          console.log('ðŸš€ ~ save ~ dict[i]:', dict[i])
        }

        function clear() {
          ctx.clearRect(0, 0, canvasEl.width, canvasEl.height)
          record = []
        }

        return () => {
          if (i >= size - 1) {
            word.innerText = JSON.stringify(dict)
            copyTextToClipboard(JSON.stringify(dict))
            downloadJSON(dict, 'dictMap')
            isRecording = false
            nextButton.innerText = 'record'
            return
          }
          if (!isRecording) {
            isRecording = true
            nextButton.innerText = 'next'

            return
          }

          show()
          save()
          clear()
          i++
        }
      })()

      function getPoint(event) {
        var x = event.clientX - rect.left
        var y = event.clientY - rect.top
        return [x * dpr, y * dpr]
      }

      // å¼€å§‹ç­¾å
      function startEvent(event) {
        var point = getPoint(event)
        beginPath(point)
        record.push({ type: 'start', point })
        canvasEl.addEventListener('mousemove', drawSign, false)
        canvasEl.addEventListener('mouseleave', removeEvent, false)
      }
      // è½¨è¿¹ç§»åŠ¨
      function removeEvent(event) {
        canvasEl.removeEventListener('mousemove', drawSign, false)
        canvasEl.removeEventListener('mouseleave', removeEvent, false)
      }
      const sendData = () => {
        const content = { type: 'canvas', id: 'signature', value: record }
        socket.send(JSON.stringify({ from: 'userId' + userId, content }))
        history = [...history, ...record]
        localStorage.setItem('localRecord', JSON.stringify(history))
        record = []
      }

      const debounceSend = debounce(sendData, 1000)

      const recoverDraw = () => {
        ctx.clearRect(0, 0, canvasEl.width, canvasEl.height)
        const localRecord = localStorage.getItem('localRecord')
        try {
          record = JSON.parse(localRecord)
          goDraw(record)
          debounceSend()
        } catch (error) {}
      }

      function drawSign(event) {
        if (isDrawing) return
        var point = getPoint(event)
        record.push({ type: 'draw', point })
        !isRecording && debounceSend()
        handleDrawSign(point)
      }

      function goDraw(value) {
        isDrawing = true
        const len = value.length
        let i = 0

        function step() {
          const item = value[i]
          if (!item) {
            isDrawing = false
            console.log('ðŸš€ ~ step ~ done:')
            return
          }

          const { type, point } = item
          if (type === 'start') {
            beginPath(point)
          } else {
            handleDrawSign(point)
          }
          if (i < len) {
            i++
            requestAnimationFrame(step)
            // step()
          }
        }

        step()
      }

      function beginPath(point) {
        ctx.beginPath.apply(ctx, getPoint(point))
      }

      function handleDrawSign(point) {
        ctx.strokeStyle = `rgba(${Math.floor(Math.random() * 255)},${Math.floor(Math.random() * 255)},${Math.floor(Math.random() * 255)},1)`
        ctx.lineTo.apply(ctx, point)
        ctx.stroke()
      }
      canvasEl.addEventListener('mouseup', removeEvent, false)
      canvasEl.addEventListener('mousedown', startEvent, false)
    </script>
  </body>
</html>
